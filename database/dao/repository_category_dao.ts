/**
 * 仓库分类关联 DAO
 */

import { BaseDAO } from './base_dao';
import { 
  RepositoryCategory, 
  CreateRepositoryCategoryData, 
  RepositoryCategorySearchParams 
} from './types';
import { SQLiteConnectionManager } from '../../services/database_service';
import { DAOException } from './dao_exception';

export class RepositoryCategoryDAO extends BaseDAO<RepositoryCategory> {
  protected tableName = 'repository_categories';
  protected allowedSortFields = [
    'id', 'repository_id', 'category_id', 'confidence', 'created_at'
  ];

  constructor(db: SQLiteConnectionManager) {
    super(db);
  }

  /**
   * 创建仓库分类关联
   */
  async create(data: CreateRepositoryCategoryData): Promise<RepositoryCategory> {
    try {
      // 检查关联是否已存在
      const existing = await this.findByRepositoryAndCategory(
        data.repository_id, 
        data.category_id
      );
      
      if (existing) {
        throw new DAOException('仓库分类关联已存在', 'ASSOCIATION_EXISTS');
      }

      return await super.create(data);
    } catch (error) {
      if (error instanceof DAOException) throw error;
      throw new DAOException(`创建仓库分类关联失败: ${error.message}`, 'CREATE_ASSOCIATION_FAILED', error);
    }
  }

  /**
   * 根据仓库和分类查找关联
   */
  async findByRepositoryAndCategory(repositoryId: number, categoryId: number): Promise<RepositoryCategory | null> {
    try {
      const sql = `
        SELECT * FROM repository_categories 
        WHERE repository_id = ? AND category_id = ?
      `;
      const result = await this.db.querySingle(sql, [repositoryId, categoryId]);
      return result || null;
    } catch (error) {
      throw new DAOException(`查找仓库分类关联失败: ${error.message}`, 'FIND_BY_REPO_CATEGORY_FAILED', error);
    }
  }

  /**
   * 获取仓库的所有分类
   */
  async getCategoriesByRepository(repositoryId: number): Promise<Array<{
    categoryId: number;
    categoryName: string;
    categoryColor: string;
    categoryIcon?: string;
    confidence?: number;
    isAutoGenerated: boolean;
    createdAt: string;
  }>> {
    try {
      const sql = `
        SELECT 
          c.id as category_id,
          c.name as category_name,
          c.color as category_color,
          c.icon as category_icon,
          rc.confidence,
          rc.is_auto_generated,
          rc.created_at
        FROM repository_categories rc
        JOIN categories c ON rc.category_id = c.id
        WHERE rc.repository_id = ?
        ORDER BY c.sort_order ASC, c.name ASC
      `;
      const result = await this.db.queryAll(sql, [repositoryId]);
      return result;
    } catch (error) {
      throw new DAOException(`获取仓库分类失败: ${error.message}`, 'GET_REPO_CATEGORIES_FAILED', error);
    }
  }

  /**
   * 获取分类下的所有仓库
   */
  async getRepositoriesByCategory(categoryId: number, params?: SearchParams): Promise<Array<{
    repositoryId: number;
    fullName: string;
    description?: string;
    language?: string;
    starsCount: number;
    confidence?: number;
    isAutoGenerated: boolean;
    createdAt: string;
  }>> {
    try {
      const searchParams = { ...params };
      const whereConditions: string[] = [];
      const queryParams: any[] = [];

      whereConditions.push('rc.category_id = ?');
      queryParams.push(categoryId);

      if (searchParams.query) {
        whereConditions.push('(r.full_name LIKE ? OR r.description LIKE ?)');
        const searchPattern = `%${searchParams.query}%`;
        queryParams.push(searchPattern, searchPattern);
      }

      let sql = `
        SELECT 
          r.id as repository_id,
          r.full_name,
          r.description,
          r.language,
          r.stars_count,
          rc.confidence,
          rc.is_auto_generated,
          rc.created_at
        FROM repository_categories rc
        JOIN repositories r ON rc.repository_id = r.id
        WHERE ${whereConditions.join(' AND ')}
      `;

      // 添加排序
      const sortBy = searchParams.sortBy || 'r.stars_count';
      const sortOrder = searchParams.sortOrder || 'DESC';
      sql += ` ORDER BY ${sortBy} ${sortOrder}`;

      // 添加分页
      if (searchParams.limit) {
        sql += ' LIMIT ?';
        queryParams.push(searchParams.limit);

        if (searchParams.offset !== undefined) {
          sql += ' OFFSET ?';
          queryParams.push(searchParams.offset);
        }
      }

      const result = await this.db.queryAll(sql, queryParams);
      return result;
    } catch (error) {
      throw new DAOException(`获取分类仓库失败: ${error.message}`, 'GET_CATEGORY_REPOS_FAILED', error);
    }
  }

  /**
   * 批量设置仓库分类
   */
  async setRepositoryCategories(repositoryId: number, categoryIds: number[], isAutoGenerated: boolean = false): Promise<void> {
    try {
      await this.db.executeInTransaction(async (tx) => {
        // 删除现有关联
        await tx.run('DELETE FROM repository_categories WHERE repository_id = ?', [repositoryId]);

        // 创建新关联
        for (const categoryId of categoryIds) {
          await tx.run(`
            INSERT INTO repository_categories (repository_id, category_id, is_auto_generated)
            VALUES (?, ?, ?)
          `, [repositoryId, categoryId, isAutoGenerated]);
        }
      });
    } catch (error) {
      throw new DAOException(`设置仓库分类失败: ${error.message}`, 'SET_REPO_CATEGORIES_FAILED', error);
    }
  }

  /**
   * 为仓库添加分类
   */
  async addCategoryToRepository(repositoryId: number, categoryId: number, confidence?: number, isAutoGenerated: boolean = false): Promise<RepositoryCategory> {
    try {
      return await this.create({
        repository_id: repositoryId,
        category_id: categoryId,
        confidence,
        is_auto_generated: isAutoGenerated
      });
    } catch (error) {
      if (error instanceof DAOException) throw error;
      throw new DAOException(`添加分类到仓库失败: ${error.message}`, 'ADD_CATEGORY_TO_REPO_FAILED', error);
    }
  }

  /**
   * 从仓库中移除分类
   */
  async removeCategoryFromRepository(repositoryId: number, categoryId: number): Promise<boolean> {
    try {
      const sql = 'DELETE FROM repository_categories WHERE repository_id = ? AND category_id = ?';
      const result = await this.db.delete(sql, [repositoryId, categoryId]);
      return result > 0;
    } catch (error) {
      throw new DAOException(`从仓库移除分类失败: ${error.message}`, 'REMOVE_CATEGORY_FROM_REPO_FAILED', error);
    }
  }

  /**
   * 清理自动生成的分类关联
   */
  async cleanupAutoGeneratedAssociations(confidenceThreshold: number = 0.5): Promise<number> {
    try {
      const sql = `
        DELETE FROM repository_categories 
        WHERE is_auto_generated = 1 
        AND (confidence IS NULL OR confidence < ?)
      `;
      const result = await this.db.delete(sql, [confidenceThreshold]);
      return result;
    } catch (error) {
      throw new DAOException(`清理自动分类失败: ${error.message}`, 'CLEANUP_AUTO_GENERATED_FAILED', error);
    }
  }

  /**
   * 获取自动分类统计
   */
  async getAutoClassificationStats(): Promise<{
    totalAssociations: number;
    autoGeneratedCount: number;
    manualCount: number;
    averageConfidence: number;
    highConfidenceCount: number;
  }> {
    try {
      const stats = await this.db.querySingle(`
        SELECT 
          COUNT(*) as total_associations,
          SUM(CASE WHEN is_auto_generated = 1 THEN 1 ELSE 0 END) as auto_generated_count,
          SUM(CASE WHEN is_auto_generated = 0 THEN 1 ELSE 0 END) as manual_count,
          AVG(confidence) as average_confidence,
          SUM(CASE WHEN confidence >= 0.8 THEN 1 ELSE 0 END) as high_confidence_count
        FROM repository_categories
        WHERE is_auto_generated = 1
      `);

      return {
        totalAssociations: stats.total_associations || 0,
        autoGeneratedCount: stats.auto_generated_count || 0,
        manualCount: stats.manual_count || 0,
        averageConfidence: Math.round((stats.average_confidence || 0) * 100) / 100,
        highConfidenceCount: stats.high_confidence_count || 0
      };
    } catch (error) {
      throw new DAOException(`获取自动分类统计失败: ${error.message}`, 'AUTO_CLASSIFICATION_STATS_FAILED', error);
    }
  }

  /**
   * 根据置信度范围查找分类关联
   */
  async findByConfidenceRange(minConfidence: number, maxConfidence?: number): Promise<RepositoryCategory[]> {
    try {
      let sql = `
        SELECT * FROM repository_categories 
        WHERE confidence >= ?
      `;
      const params = [minConfidence];

      if (maxConfidence !== undefined) {
        sql += ' AND confidence <= ?';
        params.push(maxConfidence);
      }

      sql += ' ORDER BY confidence DESC, created_at DESC';

      const result = await this.db.queryAll(sql, params);
      return result;
    } catch (error) {
      throw new DAOException(`按置信度范围查找失败: ${error.message}`, 'FIND_BY_CONFIDENCE_FAILED', error);
    }
  }

  /**
   * 获取仓库分类热度（按分类的仓库数量）
   */
  async getCategoryPopularity(): Promise<Array<{
    categoryId: number;
    categoryName: string;
    repositoryCount: number;
    autoGeneratedCount: number;
    manualCount: number;
  }>> {
    try {
      const sql = `
        SELECT 
          c.id as category_id,
          c.name as category_name,
          COUNT(rc.repository_id) as repository_count,
          SUM(CASE WHEN rc.is_auto_generated = 1 THEN 1 ELSE 0 END) as auto_generated_count,
          SUM(CASE WHEN rc.is_auto_generated = 0 THEN 1 ELSE 0 END) as manual_count
        FROM categories c
        LEFT JOIN repository_categories rc ON c.id = rc.category_id
        GROUP BY c.id, c.name
        HAVING repository_count > 0
        ORDER BY repository_count DESC, c.sort_order ASC
      `;
      const result = await this.db.queryAll(sql);
      return result;
    } catch (error) {
      throw new DAOException(`获取分类热度失败: ${error.message}`, 'GET_CATEGORY_POPULARITY_FAILED', error);
    }
  }

  /**
   * 转移分类关联
   */
  async transferAssociations(sourceCategoryId: number, targetCategoryId: number): Promise<number> {
    try {
      if (sourceCategoryId === targetCategoryId) {
        throw new DAOException('不能转移分类到自身', 'INVALID_TRANSFER_TARGET');
      }

      const sql = `
        UPDATE repository_categories 
        SET category_id = ? 
        WHERE category_id = ?
      `;
      const result = await this.db.update(sql, [targetCategoryId, sourceCategoryId]);
      return result;
    } catch (error) {
      if (error instanceof DAOException) throw error;
      throw new DAOException(`转移分类关联失败: ${error.message}`, 'TRANSFER_ASSOCIATIONS_FAILED', error);
    }
  }

  /**
   * 获取仓库的分类数量统计
   */
  async getRepositoryCategoryStats(): Promise<Array<{
    repositoryId: number;
    repositoryName: string;
    categoryCount: number;
    autoGeneratedCount: number;
    manualCount: number;
    averageConfidence: number;
  }>> {
    try {
      const sql = `
        SELECT 
          r.id as repository_id,
          r.full_name as repository_name,
          COUNT(rc.category_id) as category_count,
          SUM(CASE WHEN rc.is_auto_generated = 1 THEN 1 ELSE 0 END) as auto_generated_count,
          SUM(CASE WHEN rc.is_auto_generated = 0 THEN 1 ELSE 0 END) as manual_count,
          AVG(rc.confidence) as average_confidence
        FROM repositories r
        LEFT JOIN repository_categories rc ON r.id = rc.repository_id
        GROUP BY r.id, r.full_name
        HAVING category_count > 0
        ORDER BY category_count DESC, r.stars_count DESC
      `;
      const result = await this.db.queryAll(sql);
      return result.map(row => ({
        ...row,
        averageConfidence: Math.round((row.average_confidence || 0) * 100) / 100
      }));
    } catch (error) {
      throw new DAOException(`获取仓库分类统计失败: ${error.message}`, 'REPOSITORY_CATEGORY_STATS_FAILED', error);
    }
  }

  /**
   * 验证分类关联完整性
   */
  async validateAssociations(): Promise<{
    orphanedAssociations: number;
    invalidRepositoryIds: number[];
    invalidCategoryIds: number[];
  }> {
    try {
      // 查找孤立的关联（仓库不存在的）
      const orphaned = await this.db.querySingle(`
        SELECT COUNT(*) as count
        FROM repository_categories rc
        LEFT JOIN repositories r ON rc.repository_id = r.id
        WHERE r.id IS NULL
      `);

      // 查找孤立的分类关联（分类不存在的）
      const invalidCategories = await this.db.querySingle(`
        SELECT COUNT(*) as count
        FROM repository_categories rc
        LEFT JOIN categories c ON rc.category_id = c.id
        WHERE c.id IS NULL
      `);

      // 获取无效的仓库ID
      const invalidRepos = await this.db.queryAll(`
        SELECT DISTINCT rc.repository_id
        FROM repository_categories rc
        LEFT JOIN repositories r ON rc.repository_id = r.id
        WHERE r.id IS NULL
      `);

      // 获取无效的分类ID
      const invalidCats = await this.db.queryAll(`
        SELECT DISTINCT rc.category_id
        FROM repository_categories rc
        LEFT JOIN categories c ON rc.category_id = c.id
        WHERE c.id IS NULL
      `);

      return {
        orphanedAssociations: orphaned.count || 0,
        invalidRepositoryIds: invalidRepos.map((row: any) => row.repository_id),
        invalidCategoryIds: invalidCats.map((row: any) => row.category_id)
      };
    } catch (error) {
      throw new DAOException(`验证关联完整性失败: ${error.message}`, 'VALIDATE_ASSOCIATIONS_FAILED', error);
    }
  }

  /**
   * 清理无效关联
   */
  async cleanupInvalidAssociations(): Promise<number> {
    try {
      const sql = `
        DELETE FROM repository_categories 
        WHERE repository_id NOT IN (SELECT id FROM repositories)
        OR category_id NOT IN (SELECT id FROM categories)
      `;
      const result = await this.db.delete(sql);
      return result;
    } catch (error) {
      throw new DAOException(`清理无效关联失败: ${error.message}`, 'CLEANUP_INVALID_FAILED', error);
    }
  }
}

// 导入 SearchParams 类型
import { SearchParams } from './base_dao';
